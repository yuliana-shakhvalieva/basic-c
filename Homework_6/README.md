## Homework_6

Разработайте новый класс строки. Ваша строка должна быть близкой по интерфейсу к строке `std::basic_string`, предлагаемой в библиотеке STL.

Основное отличие - **ленивое копирование**.

Ниже приводится список требований к интерфейсу класса, который является подмножеством интерфейса STL `std::basic_string`.

- Класс `lazy_basic_string` должен представлять собой **шаблонный класс от типа символа и класса свойств символов** - аналогично STL `std::basic_string`, но **без аллокатора**.
- **Класс свойств символов должен использоваться для всех операций с символами строки** 
(например, для копирования буфера символов необходимо использовать статический метод `copy()` класса свойств).
Интерфейс класса свойств символов должен соответствовать `std::char_traits`.
- Интерфейс `lazy_basic_string` должен содержать следующие методы, аналогичные методам `std::basic_string`:
  - **Типы**: все, кроме аллокатора и итераторов.
  - **Конструкторы**: от другой ленивой строки; без параметров; **неявный (!)** от C-строки; заполнение заданным количеством указанных символов.
  - **Операторы**:
    - присваивания;
    - сложение `+=` и `+` (для ленивой строки, C-строки, символа);
    - `[]` обращение по индексу должно быть представлено двумя операторами -
    константным и неконстантным (второй не должен изменять строку, если действительного изменения символа не произошло).
    **Обратите внимание, что тип прокси объекта для реализации этой задачи не должен быть доступен клиентам вашего класса ленивой строки.**
    - сравнения ленивых строк (достаточно реализовать операторы `==`, `!=`, `<`). Как между собой, так и с С-строками.
  - **Методы** `swap()`, `clear()`, `size()`, `empty()`, `c_str()` аналогичные методам `std::basic_string`. Функция `swap()` должна быть как внутренней, так и внешней.
  - **Метод** `size()` должен иметь временную сложность `O(1)`.
- Все операции над строкой должны удовлетворять **строгой гарантии безопасности исключений**. Стоит заметить, что для этого не нужно использовать `try`/`catch`.
- **Определите синонимы вашего класса** для работы с типами `char` и `wchar_t` соответственно `lazy_string` и `lazy_wstring`.
- Обеспечьте реализацию строки `lazy_istring`, **нечувствительной к регистру при сравнении** на основе вашей реализации `lazy_basic_string`.
- Постарайтесь **минимизировать количество выделений динамической памяти**. Например, если вы используете `std::shared_ptr`, создавайте его с помощью `std::make_shared`.
- Постарайтесь **избежать дублирования хранимых данных**. Например, размер общего буфера лучше хранить в общих данных вместе с буфером, а не в каждом экземпляре строки (если вы не реализуете описанную ниже **Small Object Optimization**).
- В данной задаче **запрещено использовать готовые классы строк** (в том числе, `std::basic_string`). Остальные примитивы библиотеки STL можно и рекомендуется использовать 
  Учтите, что примитивы STL или их обычное использование могут не удовлетворять описанным требованиям данной задачи. Например, если вы используете `std::vector` для хранения буфера символов, то вы не можете использовать конструкторы копирования или операции меняющие размеры вектора, т.к. в данных операциях происходит копирование символов, которое вы обязаны делать с помощью класса свойств символов (`char traits`).
- В реализации не должно быть утечек памяти.

#### Описание файлов:
+ src - папка решением;
+ test - папка с тестами.

